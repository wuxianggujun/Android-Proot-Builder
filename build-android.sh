#!/bin/bash
# Android PRoot 交叉编译脚本
# 编译 proot、loader（从 proot 源码构建）和 talloc
#
# 支持架构：aarch64 (arm64-v8a) 和 x86_64
# 输出目录：/output
#
# 特性：
# - 增量编译（检测源码变化）
# - 包名无关（不做包名替换）

set -e

# 禁用输出缓冲，确保实时显示
export PYTHONUNBUFFERED=1
stty -icanon -echo 2>/dev/null || true

# ============ 配置 ============

# 目标架构（从环境变量获取，默认 aarch64）
TARGET_ARCH="${TARGET_ARCH:-aarch64}"

# Android API 级别
ANDROID_API=28

# NDK 路径
NDK="${ANDROID_NDK_HOME}"

# 输出目录
OUTPUT_DIR="/output"
mkdir -p "${OUTPUT_DIR}"
TALLOC_LINK_MARKER="${OUTPUT_DIR}/.talloc_link_mode"

# 源码目录（持久化 volume）
SRC_DIR="/build/src"


# talloc 链接方式：shared（默认，输出并运行时依赖 libtalloc.so.2）/ static（将 talloc 静态链接进 proot）
TALLOC_LINK="${TALLOC_LINK:-shared}"
case "${TALLOC_LINK}" in
    shared|static) ;;
    *)
        echo "[ERROR] Unsupported TALLOC_LINK: ${TALLOC_LINK} (supported: shared|static)"
        exit 1
        ;;
esac

# 是否将 libtalloc.so.2 作为构建产物输出到 /output
# - 默认：shared=输出；static=不输出（避免误以为仍需要分发 .so）
EMIT_TALLOC_SO="${EMIT_TALLOC_SO:-}"
if [ -z "${EMIT_TALLOC_SO}" ]; then
    if [ "${TALLOC_LINK}" = "shared" ]; then
        EMIT_TALLOC_SO=1
    else
        EMIT_TALLOC_SO=0
    fi
fi
case "${EMIT_TALLOC_SO}" in
    1|true|yes|on) EMIT_TALLOC_SO=1 ;;
    0|false|no|off) EMIT_TALLOC_SO=0 ;;
    *)
        echo "[ERROR] Unsupported EMIT_TALLOC_SO: ${EMIT_TALLOC_SO} (supported: 0/1, false/true)"
        exit 1
        ;;
esac

# 颜色输出
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log_info() { echo -e "${CYAN}[INFO]${NC} $1"; }
log_success() { echo -e "${GREEN}[OK]${NC} $1"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $1"; }
log_error() { echo -e "${RED}[ERROR]${NC} $1"; }

# ============ 工具链配置 ============

case "${TARGET_ARCH}" in
    aarch64|arm64)
        ANDROID_ABI="arm64-v8a"
        TOOLCHAIN_PREFIX="aarch64-linux-android"
        CLANG_TARGET="aarch64-linux-android${ANDROID_API}"
        ;;
    x86_64)
        ANDROID_ABI="x86_64"
        TOOLCHAIN_PREFIX="x86_64-linux-android"
        CLANG_TARGET="x86_64-linux-android${ANDROID_API}"
        ;;
    *)
        echo "[ERROR] Unsupported architecture: ${TARGET_ARCH}"
        echo "Supported: aarch64, x86_64"
        exit 1
        ;;
esac

echo ""
echo "============================================"
log_info "Android PRoot 编译"
echo "============================================"
echo "  目标架构:    ${TARGET_ARCH}"
echo "  Android ABI: ${ANDROID_ABI}"
echo "  Android API: ${ANDROID_API}"
echo "  talloc 链接:  ${TALLOC_LINK} (emit_so=${EMIT_TALLOC_SO})"
echo "  NDK:         ${NDK}"
echo "  输出目录:    ${OUTPUT_DIR}"
echo "============================================"
echo ""

# NDK 工具链
TOOLCHAIN="${NDK}/toolchains/llvm/prebuilt/linux-x86_64"
export CC="${TOOLCHAIN}/bin/${CLANG_TARGET}-clang"
export CXX="${TOOLCHAIN}/bin/${CLANG_TARGET}-clang++"
export AR="${TOOLCHAIN}/bin/llvm-ar"
export AS="${CC}"
export LD="${TOOLCHAIN}/bin/ld.lld"
export RANLIB="${TOOLCHAIN}/bin/llvm-ranlib"
export STRIP="${TOOLCHAIN}/bin/llvm-strip"
export OBJCOPY="${TOOLCHAIN}/bin/llvm-objcopy"
export OBJDUMP="${TOOLCHAIN}/bin/llvm-objdump"

# 编译选项
export CFLAGS="-O2 -fPIC -fPIE"
export CXXFLAGS="${CFLAGS}"
export LDFLAGS="-pie"

# 检查工具链
if [ ! -f "${CC}" ]; then
    log_error "Compiler not found: ${CC}"
    exit 1
fi

log_info "Using compiler: ${CC}"
${CC} --version | head -1

# 检查源码是否已准备
if [ ! -f "${SRC_DIR}/.proot-builder-prepared" ]; then
    log_error "源码未准备！请先运行 prepare-source.sh"
    exit 1
fi

# proot 源码目录（包含 GNUmakefile 与 loader 源码）
PROOT_SRC_DIR="${SRC_DIR}/proot/src"
PROOT_MAKEFILE="${PROOT_SRC_DIR}/GNUmakefile"

# ============ talloc 交叉编译 cross-answers ============

TALLOC_CROSS_ANSWERS="${SRC_DIR}/talloc-cross-answers-${TARGET_ARCH}.txt"

write_talloc_cross_answers() {
    local uname_machine
    case "${TARGET_ARCH}" in
        aarch64|arm64) uname_machine="aarch64" ;;
        x86_64) uname_machine="x86_64" ;;
        *) uname_machine="${TARGET_ARCH}" ;;
    esac

    cat > "${TALLOC_CROSS_ANSWERS}" << EOF
# Auto-generated by build-android.sh
# Target arch: ${TARGET_ARCH}

Checking uname sysname type: "Linux"
Checking uname machine type: "${uname_machine}"
Checking uname release type: "5.4.0"
Checking uname version type: "#1 SMP PREEMPT"

Checking getconf LFS_CFLAGS: NO
Checking for large file support without additional flags: OK
Checking for -D_FILE_OFFSET_BITS=64: OK
Checking for -D_LARGE_FILES: OK

Checking correct behavior of strtoll: OK
Checking for working strptime: OK
Checking for C99 vsnprintf: OK

Checking for HAVE_SHARED_MMAP: OK
Checking for HAVE_MREMAP: OK
Checking for HAVE_INCOHERENT_MMAP: NO
Checking for HAVE_SECURE_MKSTEMP: OK

Checking for HAVE_IFACE_GETIFADDRS: OK
Checking for HAVE_IFACE_AIX: NO
Checking for HAVE_IFACE_IFCONF: NO
Checking for HAVE_IFACE_IFREQ: NO

Checking for HAVE_LITTLE_ENDIAN - runtime: OK
Checking for HAVE_BIG_ENDIAN - runtime: NO

rpath library support: OK
-Wl,--version-script support: FAIL
EOF
}

# ============ 编译 talloc ============

echo ""
echo "============================================"
log_info "编译 talloc..."
echo "============================================"

TALLOC_DIR="${SRC_DIR}/talloc"
TALLOC_BUILD="${SRC_DIR}/talloc-build-${TARGET_ARCH}"
TALLOC_OUTPUT="${OUTPUT_DIR}/libtalloc.so.2"
TALLOC_HEADER="${TALLOC_BUILD}/include/talloc.h"
TALLOC_INSTALLED_LIB_GLOB="${TALLOC_BUILD}/lib/libtalloc.so*"
TALLOC_STATIC_LIB="${TALLOC_BUILD}/lib/libtalloc.a"

# 检查是否需要重新编译（增量编译）
need_rebuild_talloc=false
if [ ! -f "${TALLOC_HEADER}" ]; then
    need_rebuild_talloc=true
    log_warn "talloc: 缺少头文件（${TALLOC_HEADER}），需要重新编译"
elif ! ls ${TALLOC_INSTALLED_LIB_GLOB} >/dev/null 2>&1; then
    need_rebuild_talloc=true
    log_warn "talloc: 缺少安装库文件（${TALLOC_BUILD}/lib/），需要重新编译"
elif [ "${TALLOC_LINK}" = "static" ] && [ ! -f "${TALLOC_STATIC_LIB}" ]; then
    need_rebuild_talloc=true
    log_warn "talloc: 需要静态链接但缺少 ${TALLOC_STATIC_LIB}，需要重新编译"
elif [ -d "${TALLOC_DIR}" ]; then
    # 检查源码是否比已安装库/静态库新（static 模式下可能不输出 ${TALLOC_OUTPUT}）
    talloc_ref=""
    if [ -f "${TALLOC_STATIC_LIB}" ]; then
        talloc_ref="${TALLOC_STATIC_LIB}"
    else
        talloc_ref="$(ls -1 ${TALLOC_INSTALLED_LIB_GLOB} 2>/dev/null | head -n 1 || true)"
    fi
    if [ -n "${talloc_ref}" ]; then
        newest_src=$(find "${TALLOC_DIR}" -name "*.c" -newer "${talloc_ref}" 2>/dev/null | head -1)
        if [ -n "${newest_src}" ]; then
            need_rebuild_talloc=true
            log_info "talloc: 源码已更新，需要重新编译"
        fi
    fi
fi

if [ -d "${TALLOC_DIR}" ]; then
    if [ "$need_rebuild_talloc" = true ]; then
        cd "${TALLOC_DIR}"
        
        # 清理之前的构建
        rm -rf "${TALLOC_BUILD}"
        mkdir -p "${TALLOC_BUILD}"
        
        log_info "配置 talloc..."
        
        # 配置 talloc（使用 waf 构建系统）
        log_info "配置参数:"
        log_info "  --prefix=${TALLOC_BUILD}"
        log_info "  --cross-compile"
        log_info "  --cross-answers=${TALLOC_CROSS_ANSWERS}"
        write_talloc_cross_answers
        log_info "  已生成 cross-answers: ${TALLOC_CROSS_ANSWERS}"
         
        ./configure \
            --prefix="${TALLOC_BUILD}" \
            --cross-compile \
            --cross-answers="${TALLOC_CROSS_ANSWERS}" \
            --disable-python \
            --without-gettext 2>&1 | tee /tmp/talloc-configure.log
        
        # 编译（显示详细输出）
        log_info "编译中（使用 $(nproc) 个并行任务）..."
        make -j$(nproc) V=1 2>&1 | while IFS= read -r line; do
            # 只显示重要信息，过滤掉过于详细的编译命令
            if echo "$line" | grep -qE "(CC|LD|AR|RANLIB|Building|Linking|Error|error|Warning|warning)"; then
                echo "  $line"
            fi
        done
        
        log_info "安装到构建目录..."
        make install 2>&1 | grep -v "^make"
    
        # 生成静态库（talloc 默认只安装 .so；为了可选静态链接到 proot，这里从 waf 产物拼一个 .a）
        if [ "${TALLOC_LINK}" = "static" ]; then
            log_info "生成静态库 libtalloc.a..."
            mapfile -t TALLOC_OBJS < <(ls -1 "${TALLOC_DIR}/bin/default"/talloc.c.*.o 2>/dev/null || true)
            if [ "${#TALLOC_OBJS[@]}" -eq 0 ]; then
                log_error "talloc objects not found for static archive: ${TALLOC_DIR}/bin/default/talloc.c.*.o"
                exit 1
            fi
            mkdir -p "${TALLOC_BUILD}/lib"
            rm -f "${TALLOC_STATIC_LIB}"
            "${AR}" rcs "${TALLOC_STATIC_LIB}" "${TALLOC_OBJS[@]}"
            if [ ! -f "${TALLOC_STATIC_LIB}" ]; then
                log_error "failed to create: ${TALLOC_STATIC_LIB}"
                exit 1
            fi
            log_success "已生成: ${TALLOC_STATIC_LIB}"
        fi
    else
        log_info "talloc: 跳过编译（已是最新）"
    fi

    # 是否输出 libtalloc.so.2 到 /output
    if [ "${EMIT_TALLOC_SO}" = "1" ]; then
        TALLOC_LIB=$(find "${TALLOC_BUILD}" -name "libtalloc.so*" -type f | head -1)
        if [ -n "${TALLOC_LIB}" ]; then
            cp "${TALLOC_LIB}" "${TALLOC_OUTPUT}"
            log_success "talloc 输出完成: ${TALLOC_OUTPUT}"
        else
            log_error "talloc library not found (expected under ${TALLOC_BUILD})"
            exit 1
        fi
    else
        # static 模式默认不输出 .so：清理旧残留，避免误以为需要随 APK 分发
        if [ -f "${TALLOC_OUTPUT}" ]; then
            rm -f "${TALLOC_OUTPUT}"
        fi
        log_info "talloc: 不输出 libtalloc.so.2（static 链接模式）"
    fi
else
    log_warn "talloc source not found, using pre-built version if available"
fi

# ============ 编译 proot-loader（从 proot 源码构建） ============

echo ""
echo "============================================"
log_info "编译 proot-loader..."
echo "============================================"

LOADER_OUTPUT="${OUTPUT_DIR}/libproot-loader.so"

# 检查是否需要重新编译
need_rebuild_loader=false
if [ ! -f "${LOADER_OUTPUT}" ]; then
    need_rebuild_loader=true
    log_info "proot-loader: 输出不存在，需要编译"
elif [ -d "${PROOT_SRC_DIR}/loader" ]; then
    newest_src=$(find "${PROOT_SRC_DIR}/loader" -type f -newer "${LOADER_OUTPUT}" 2>/dev/null | head -1)
    if [ -n "${newest_src}" ]; then
        need_rebuild_loader=true
        log_info "proot-loader: 源码已更新，需要重新编译"
    fi
fi

# 架构校验：避免不同架构复用同一源码目录导致产物错架构
if [ -f "${LOADER_OUTPUT}" ]; then
    expected_loader_desc=""
    case "${TARGET_ARCH}" in
        aarch64|arm64) expected_loader_desc="ARM aarch64" ;;
        x86_64) expected_loader_desc="x86-64" ;;
    esac
    if [ -n "${expected_loader_desc}" ] && ! file -b "${LOADER_OUTPUT}" | grep -q "${expected_loader_desc}"; then
        need_rebuild_loader=true
        log_warn "proot-loader: 产物架构不匹配（期望: ${expected_loader_desc}），需要重新编译"
    fi
fi

if [ "$need_rebuild_loader" = true ]; then
    if [ ! -f "${PROOT_MAKEFILE}" ]; then
        log_error "proot 源码不存在或不完整（缺少 GNUmakefile）: ${PROOT_MAKEFILE}"
        exit 1
    fi

    cd "${PROOT_SRC_DIR}"
    # 注意：proot 源码目录在不同架构之间复用（同一个 volume），make 可能误判“已是最新”而保留上次架构产物。
    # 这里强制重建 loader，确保输出架构正确。
    make -B -j"$(nproc)" CC="${CC}" CFLAGS="${CFLAGS}" V=1 loader/loader

    if [ -f "loader/loader" ]; then
        cp "loader/loader" "${LOADER_OUTPUT}"
        log_success "proot-loader 编译完成: ${LOADER_OUTPUT}"
    else
        log_error "proot-loader binary not found: ${PROOT_SRC_DIR}/loader/loader"
        exit 1
    fi
else
    log_info "proot-loader: 跳过编译（已是最新）"
fi

# ============ 编译 proot-loader32（仅 arm64，使用 proot 的 loader-m32） ============

if [ "${TARGET_ARCH}" = "aarch64" ]; then
    echo ""
    echo "============================================"
    log_info "编译 proot-loader32 (32-bit compat)..."
    echo "============================================"

    LOADER32_OUTPUT="${OUTPUT_DIR}/libproot-loader32.so"

    # 检查是否需要重新编译
    need_rebuild_loader32=false
    if [ ! -f "${LOADER32_OUTPUT}" ]; then
        need_rebuild_loader32=true
    elif ! file -b "${LOADER32_OUTPUT}" | grep -q "ELF 32-bit" || ! file -b "${LOADER32_OUTPUT}" | grep -q "ARM"; then
        need_rebuild_loader32=true
        log_warn "proot-loader32: 产物架构不匹配（期望: ELF 32-bit ARM），需要重新编译"
    elif [ -d "${PROOT_SRC_DIR}/loader" ]; then
        newest_src=$(find "${PROOT_SRC_DIR}/loader" -type f -newer "${LOADER32_OUTPUT}" 2>/dev/null | head -1)
        if [ -n "${newest_src}" ]; then
            need_rebuild_loader32=true
        fi
    fi

    if [ "$need_rebuild_loader32" = true ]; then
        cd "${PROOT_SRC_DIR}"
        make -B -j"$(nproc)" CC="${CC}" CFLAGS="${CFLAGS}" V=1 loader/loader-m32

        if [ -f "loader/loader-m32" ]; then
            cp "loader/loader-m32" "${LOADER32_OUTPUT}"
            log_success "proot-loader32 编译完成: ${LOADER32_OUTPUT}"
        else
            log_warn "proot-loader32 skipped (loader-m32 not produced)"
        fi
    else
        log_info "proot-loader32: 跳过编译（已是最新）"
    fi
fi

# ============ 编译 proot ============

echo ""
echo "============================================"
log_info "编译 proot..."
echo "============================================"

PROOT_DIR="${SRC_DIR}/proot/src"
PROOT_BUILD="${SRC_DIR}/proot-build-${TARGET_ARCH}"
PROOT_OUTPUT="${OUTPUT_DIR}/libproot.so"

# 检查是否需要重新编译
need_rebuild_proot=false
if [ ! -f "${PROOT_OUTPUT}" ]; then
    need_rebuild_proot=true
    log_info "proot: 输出不存在，需要编译"
elif [ ! -f "${TALLOC_LINK_MARKER}" ] || [ "$(cat "${TALLOC_LINK_MARKER}" 2>/dev/null)" != "${TALLOC_LINK}" ]; then
    need_rebuild_proot=true
    log_info "proot: talloc 链接方式变化（$(cat "${TALLOC_LINK_MARKER}" 2>/dev/null || echo 'none') -> ${TALLOC_LINK}），需要重新编译"
elif [ -d "${PROOT_DIR}" ]; then
    newest_src=$(find "${PROOT_DIR}" -name "*.c" -newer "${PROOT_OUTPUT}" 2>/dev/null | head -1)
    if [ -n "${newest_src}" ]; then
        need_rebuild_proot=true
        log_info "proot: 源码已更新，需要重新编译"
    fi
fi

if [ -d "${PROOT_DIR}" ]; then
    if [ "$need_rebuild_proot" = true ]; then
        cd "${PROOT_DIR}"
        
        # 设置 talloc 路径
        TALLOC_BUILD="${SRC_DIR}/talloc-build-${TARGET_ARCH}"
        export CFLAGS="${CFLAGS} -I${TALLOC_BUILD}/include"
        if [ "${TALLOC_LINK}" = "static" ]; then
            if [ ! -f "${TALLOC_BUILD}/lib/libtalloc.a" ]; then
                log_error "talloc static library not found: ${TALLOC_BUILD}/lib/libtalloc.a"
                exit 1
            fi
            export LDFLAGS="${LDFLAGS} ${TALLOC_BUILD}/lib/libtalloc.a"
        else
            export LDFLAGS="${LDFLAGS} -L${TALLOC_BUILD}/lib -ltalloc"
        fi
        
        # proot 在运行时优先使用环境变量 PROOT_LOADER/PROOT_LOADER_32；
        # 为了兼容 Android 的可执行文件限制，这里不启用“解包 loader 到固定目录”的编译选项。
        
        # 清理
        log_info "清理旧构建..."
        make clean 2>&1 | head -5 || true
        
        # 编译（显示进度）
        log_info "编译 proot..."
        log_info "  使用 $(nproc) 个并行任务"
        log_info "  编译器: ${CC}"
        
        make -j$(nproc) \
            CC="${CC}" \
            CFLAGS="${CFLAGS}" \
            LDFLAGS="${LDFLAGS}" \
            V=1 2>&1 | while IFS= read -r line; do
            # 显示编译进度
            if echo "$line" | grep -qE "(CC|LD|AR|Building|Linking|\.c|\.o|Error|error|Warning|warning)"; then
                echo "  $line"
            fi
        done
        
        if [ -f "proot" ]; then
            # 重命名为 libproot.so（Android 只允许执行 lib*.so）
            cp "proot" "${PROOT_OUTPUT}"
            echo -n "${TALLOC_LINK}" > "${TALLOC_LINK_MARKER}"
            log_success "proot 编译完成: ${PROOT_OUTPUT}"
        else
            log_error "proot binary not found"
            exit 1
        fi
    else
        log_info "proot: 跳过编译（已是最新）"
    fi
else
    log_error "proot source not found: ${PROOT_DIR}"
    exit 1
fi

# ============ 完成 ============

echo ""
echo "============================================"
log_success "编译完成！"
echo "============================================"
echo ""
echo "输出文件:"
ls -la "${OUTPUT_DIR}/"
echo ""

# 验证 ELF 格式
echo "ELF 格式验证:"
for f in "${OUTPUT_DIR}"/*.so*; do
    if [ -f "$f" ]; then
        if file "$f" | grep -q "ELF"; then
            echo -e "  ${GREEN}[OK]${NC} $(basename $f): $(file -b $f | cut -d',' -f1-2)"
        else
            echo -e "  ${RED}[FAIL]${NC} $(basename $f): 不是有效的 ELF 文件"
        fi
    fi
done

echo ""
echo "下一步:"
echo "  将文件复制到项目:"
echo "    app/src/main/jniLibs/${ANDROID_ABI}/"
echo ""
echo "  或使用 PowerShell 脚本自动复制:"
echo "    .\\build-proot.ps1 -CopyToJniLibs"
